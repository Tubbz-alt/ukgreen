/* This file was generated by SableCC (http://www.sablecc.org/). */

package Epl.parser;

import Epl.lexer.*;
import Epl.node.*;
import Epl.analysis.*;
import java.util.*;

import java.io.DataInputStream;
import java.io.BufferedInputStream;
import java.io.IOException;

public class Parser
{
    public final Analysis ignoredTokens = new AnalysisAdapter();

    protected Node node;

    private final Lexer lexer;
    private final ListIterator stack = new LinkedList().listIterator();
    private int last_shift;
    private int last_pos;
    private int last_line;
    private final TokenIndex converter = new TokenIndex();
    private final int[] action = new int[2];

    private final static int SHIFT = 0;
    private final static int REDUCE = 1;
    private final static int ACCEPT = 2;
    private final static int ERROR = 3;

    protected void filter() throws ParserException, LexerException, IOException
    {
    }

    public Parser(Lexer lexer)
    {
        this.lexer = lexer;

        if(actionTable == null)
        {
            try
            {
                DataInputStream s = new DataInputStream(
                    new BufferedInputStream(
                    Parser.class.getResourceAsStream("parser.dat")));

                // read actionTable
                int length = s.readInt();
                actionTable = new int[length][][];
                for(int i = 0; i < actionTable.length; i++)
                {
                    length = s.readInt();
                    actionTable[i] = new int[length][3];
                    for(int j = 0; j < actionTable[i].length; j++)
                    {
                        for(int k = 0; k < 3; k++)
                        {
                            actionTable[i][j][k] = s.readInt();
                        }
                    }
                }

                // read gotoTable
                length = s.readInt();
                gotoTable = new int[length][][];
                for(int i = 0; i < gotoTable.length; i++)
                {
                    length = s.readInt();
                    gotoTable[i] = new int[length][2];
                    for(int j = 0; j < gotoTable[i].length; j++)
                    {
                        for(int k = 0; k < 2; k++)
                        {
                            gotoTable[i][j][k] = s.readInt();
                        }
                    }
                }

                // read errorMessages
                length = s.readInt();
                errorMessages = new String[length];
                for(int i = 0; i < errorMessages.length; i++)
                {
                    length = s.readInt();
                    StringBuffer buffer = new StringBuffer();

                    for(int j = 0; j < length; j++)
                    {
                        buffer.append(s.readChar());
                    }
                    errorMessages[i] = buffer.toString();
                }

                // read errors
                length = s.readInt();
                errors = new int[length];
                for(int i = 0; i < errors.length; i++)
                {
                    errors[i] = s.readInt();
                }

                s.close();
            }
            catch(Exception e)
            {
                throw new RuntimeException("Unable to read parser.dat.");
            }
        }
    }

    private int goTo(int index)
    {
        int state = state();
        int low = 1;
        int high = gotoTable[index].length - 1;
        int value = gotoTable[index][0][1];

        while(low <= high)
        {
            int middle = (low + high) / 2;

            if(state < gotoTable[index][middle][0])
            {
                high = middle - 1;
            }
            else if(state > gotoTable[index][middle][0])
            {
                low = middle + 1;
            }
            else
            {
                value = gotoTable[index][middle][1];
                break;
            }
        }

        return value;
    }

    private void push(int state, Node node, boolean filter) throws ParserException, LexerException, IOException
    {
        this.node = node;

        if(filter)
        {
            filter();
        }

        if(!stack.hasNext())
        {
            stack.add(new State(state, this.node));
            return;
        }

        State s = (State) stack.next();
        s.state = state;
        s.node = this.node;
    }

    private int state()
    {
        State s = (State) stack.previous();
        stack.next();
        return s.state;
    }

    private Node pop()
    {
        return (Node) ((State) stack.previous()).node;
    }

    private int index(Switchable token)
    {
        converter.index = -1;
        token.apply(converter);
        return converter.index;
    }

    public Start parse() throws ParserException, LexerException, IOException
    {
        push(0, null, false);

        List ign = null;
        while(true)
        {
            while(index(lexer.peek()) == -1)
            {
                if(ign == null)
                {
                    ign = new TypedLinkedList(NodeCast.instance);
                }

                ign.add(lexer.next());
            }

            if(ign != null)
            {
                ignoredTokens.setIn(lexer.peek(), ign);
                ign = null;
            }

            last_pos = lexer.peek().getPos();
            last_line = lexer.peek().getLine();

            int index = index(lexer.peek());
            action[0] = actionTable[state()][0][1];
            action[1] = actionTable[state()][0][2];

            int low = 1;
            int high = actionTable[state()].length - 1;

            while(low <= high)
            {
                int middle = (low + high) / 2;

                if(index < actionTable[state()][middle][0])
                {
                    high = middle - 1;
                }
                else if(index > actionTable[state()][middle][0])
                {
                    low = middle + 1;
                }
                else
                {
                    action[0] = actionTable[state()][middle][1];
                    action[1] = actionTable[state()][middle][2];
                    break;
                }
            }

            switch(action[0])
            {
                case SHIFT:
                    push(action[1], lexer.next(), true);
                    last_shift = action[1];
                    break;
                case REDUCE:
                    switch(action[1])
                    {
                    case 0: { Node node = new0(); push(goTo(0), node, true); } break;
                    case 1: { Node node = new1(); push(goTo(1), node, true); } break;
                    case 2: { Node node = new2(); push(goTo(2), node, true); } break;
                    case 3: { Node node = new3(); push(goTo(2), node, true); } break;
                    case 4: { Node node = new4(); push(goTo(17), node, false); } break;
                    case 5: { Node node = new5(); push(goTo(17), node, false); } break;
                    case 6: { Node node = new6(); push(goTo(3), node, true); } break;
                    case 7: { Node node = new7(); push(goTo(4), node, true); } break;
                    case 8: { Node node = new8(); push(goTo(5), node, true); } break;
                    case 9: { Node node = new9(); push(goTo(6), node, true); } break;
                    case 10: { Node node = new10(); push(goTo(6), node, true); } break;
                    case 11: { Node node = new11(); push(goTo(18), node, false); } break;
                    case 12: { Node node = new12(); push(goTo(18), node, false); } break;
                    case 13: { Node node = new13(); push(goTo(7), node, true); } break;
                    case 14: { Node node = new14(); push(goTo(7), node, true); } break;
                    case 15: { Node node = new15(); push(goTo(19), node, false); } break;
                    case 16: { Node node = new16(); push(goTo(19), node, false); } break;
                    case 17: { Node node = new17(); push(goTo(8), node, true); } break;
                    case 18: { Node node = new18(); push(goTo(9), node, true); } break;
                    case 19: { Node node = new19(); push(goTo(10), node, true); } break;
                    case 20: { Node node = new20(); push(goTo(11), node, true); } break;
                    case 21: { Node node = new21(); push(goTo(12), node, true); } break;
                    case 22: { Node node = new22(); push(goTo(13), node, true); } break;
                    case 23: { Node node = new23(); push(goTo(13), node, true); } break;
                    case 24: { Node node = new24(); push(goTo(14), node, true); } break;
                    case 25: { Node node = new25(); push(goTo(14), node, true); } break;
                    case 26: { Node node = new26(); push(goTo(14), node, true); } break;
                    case 27: { Node node = new27(); push(goTo(14), node, true); } break;
                    case 28: { Node node = new28(); push(goTo(14), node, true); } break;
                    case 29: { Node node = new29(); push(goTo(14), node, true); } break;
                    case 30: { Node node = new30(); push(goTo(15), node, true); } break;
                    case 31: { Node node = new31(); push(goTo(15), node, true); } break;
                    case 32: { Node node = new32(); push(goTo(20), node, false); } break;
                    case 33: { Node node = new33(); push(goTo(20), node, false); } break;
                    case 34: { Node node = new34(); push(goTo(16), node, true); } break;
                    }
                    break;
                case ACCEPT:
                    {
                        EOF node2 = (EOF) lexer.next();
                        PProgram node1 = (PProgram) pop();
                        Start node = new Start(node1, node2);
                        return node;
                    }
                case ERROR:
                    throw new ParserException(
                        "[" + last_line + "," + last_pos + "] " +
                        errorMessages[errors[action[1]]]);
            }
        }
    }

    Node new0()
    {
        PStatementlist node1 = (PStatementlist) pop();
        AProgram node = new AProgram(node1);
        return node;
    }

    Node new1()
    {
        TKet node3 = (TKet) pop();
        PList node2 = (PList) pop();
        TBra node1 = (TBra) pop();
        ABralist node = new ABralist(node1, node2, node3);
        return node;
    }

    Node new2()
    {
        XPAtom node2 = null;
        PHead node1 = (PHead) pop();
        AList node = new AList(node1, node2);
        return node;
    }

    Node new3()
    {
        XPAtom node2 = (XPAtom) pop();
        PHead node1 = (PHead) pop();
        AList node = new AList(node1, node2);
        return node;
    }

    Node new4()
    {
        PAtom node2 = (PAtom) pop();
        XPAtom node1 = (XPAtom) pop();
        X1PAtom node = new X1PAtom(node1, node2);
        return node;
    }

    Node new5()
    {
        PAtom node1 = (PAtom) pop();
        X2PAtom node = new X2PAtom(node1);
        return node;
    }

    Node new6()
    {
        PAtom node1 = (PAtom) pop();
        AHead node = new AHead(node1);
        return node;
    }

    Node new7()
    {
        TIdentifier node1 = (TIdentifier) pop();
        ANonf node = new ANonf(node1);
        return node;
    }

    Node new8()
    {
        TIdentifier node1 = (TIdentifier) pop();
        ANonp node = new ANonp(node1);
        return node;
    }

    Node new9()
    {
        TKet node4 = (TKet) pop();
        XPNonf node3 = null;
        TBra node2 = (TBra) pop();
        TNonft node1 = (TNonft) pop();
        ANonfin node = new ANonfin(node1, node2, node3, node4);
        return node;
    }

    Node new10()
    {
        TKet node4 = (TKet) pop();
        XPNonf node3 = (XPNonf) pop();
        TBra node2 = (TBra) pop();
        TNonft node1 = (TNonft) pop();
        ANonfin node = new ANonfin(node1, node2, node3, node4);
        return node;
    }

    Node new11()
    {
        PNonf node2 = (PNonf) pop();
        XPNonf node1 = (XPNonf) pop();
        X1PNonf node = new X1PNonf(node1, node2);
        return node;
    }

    Node new12()
    {
        PNonf node1 = (PNonf) pop();
        X2PNonf node = new X2PNonf(node1);
        return node;
    }

    Node new13()
    {
        TKet node4 = (TKet) pop();
        XPNonp node3 = null;
        TBra node2 = (TBra) pop();
        TNonpt node1 = (TNonpt) pop();
        ANonprod node = new ANonprod(node1, node2, node3, node4);
        return node;
    }

    Node new14()
    {
        TKet node4 = (TKet) pop();
        XPNonp node3 = (XPNonp) pop();
        TBra node2 = (TBra) pop();
        TNonpt node1 = (TNonpt) pop();
        ANonprod node = new ANonprod(node1, node2, node3, node4);
        return node;
    }

    Node new15()
    {
        PNonp node2 = (PNonp) pop();
        XPNonp node1 = (XPNonp) pop();
        X1PNonp node = new X1PNonp(node1, node2);
        return node;
    }

    Node new16()
    {
        PNonp node1 = (PNonp) pop();
        X2PNonp node = new X2PNonp(node1);
        return node;
    }

    Node new17()
    {
        TIdentifier node2 = (TIdentifier) pop();
        TFloatingConstant node1 = (TFloatingConstant) pop();
        AAtom node = new AAtom(node1, node2);
        return node;
    }

    Node new18()
    {
        PBralist node2 = (PBralist) pop();
        TTarg node1 = (TTarg) pop();
        ATarget node = new ATarget(node1, node2);
        return node;
    }

    Node new19()
    {
        PAtom node2 = (PAtom) pop();
        TRes node1 = (TRes) pop();
        AResource node = new AResource(node1, node2);
        return node;
    }

    Node new20()
    {
        PProduct node5 = (PProduct) pop();
        TArrow node4 = (TArrow) pop();
        PBralist node3 = (PBralist) pop();
        TIdentifier node2 = (TIdentifier) pop();
        TTech node1 = (TTech) pop();
        ATechnique node = new ATechnique(node1, node2, node3, node4, node5);
        return node;
    }

    Node new21()
    {
        PProducttail node1 = (PProducttail) pop();
        AProduct node = new AProduct(node1);
        return node;
    }

    Node new22()
    {
        PAtom node1 = (PAtom) pop();
        AProducttail node = new AProducttail(node1);
        return node;
    }

    Node new23()
    {
        PBralist node1 = (PBralist) pop();
        AJointProducttail node = new AJointProducttail(node1);
        return node;
    }

    Node new24()
    {
        PResource node1 = (PResource) pop();
        AResstatStatement node = new AResstatStatement(node1);
        return node;
    }

    Node new25()
    {
        PTechnique node1 = (PTechnique) pop();
        ATechstatStatement node = new ATechstatStatement(node1);
        return node;
    }

    Node new26()
    {
        PTechnique node2 = (PTechnique) pop();
        TFrozen node1 = (TFrozen) pop();
        AFtechstatStatement node = new AFtechstatStatement(node1, node2);
        return node;
    }

    Node new27()
    {
        PTarget node1 = (PTarget) pop();
        ATargstatStatement node = new ATargstatStatement(node1);
        return node;
    }

    Node new28()
    {
        PNonfin node1 = (PNonfin) pop();
        AFinalstatStatement node = new AFinalstatStatement(node1);
        return node;
    }

    Node new29()
    {
        PNonprod node1 = (PNonprod) pop();
        AProdstatStatement node = new AProdstatStatement(node1);
        return node;
    }

    Node new30()
    {
        XPStatements node3 = null;
        TSemicolon node2 = (TSemicolon) pop();
        PStatement node1 = (PStatement) pop();
        AStatementlist node = new AStatementlist(node1, node2, node3);
        return node;
    }

    Node new31()
    {
        XPStatements node3 = (XPStatements) pop();
        TSemicolon node2 = (TSemicolon) pop();
        PStatement node1 = (PStatement) pop();
        AStatementlist node = new AStatementlist(node1, node2, node3);
        return node;
    }

    Node new32()
    {
        PStatements node2 = (PStatements) pop();
        XPStatements node1 = (XPStatements) pop();
        X1PStatements node = new X1PStatements(node1, node2);
        return node;
    }

    Node new33()
    {
        PStatements node1 = (PStatements) pop();
        X2PStatements node = new X2PStatements(node1);
        return node;
    }

    Node new34()
    {
        TSemicolon node2 = (TSemicolon) pop();
        PStatement node1 = (PStatement) pop();
        AStatements node = new AStatements(node1, node2);
        return node;
    }

    private static int[][][] actionTable;
/*      {
			{{-1, ERROR, 0}, {1, SHIFT, 1}, {2, SHIFT, 2}, {3, SHIFT, 3}, {4, SHIFT, 4}, {5, SHIFT, 5}, {6, SHIFT, 6}, },
			{{-1, ERROR, 1}, {2, SHIFT, 2}, },
			{{-1, ERROR, 2}, {11, SHIFT, 16}, },
			{{-1, ERROR, 3}, {0, SHIFT, 17}, },
			{{-1, ERROR, 4}, {7, SHIFT, 19}, },
			{{-1, ERROR, 5}, {7, SHIFT, 21}, },
			{{-1, ERROR, 6}, {7, SHIFT, 22}, },
			{{-1, ERROR, 7}, {13, ACCEPT, -1}, },
			{{-1, REDUCE, 28}, },
			{{-1, REDUCE, 29}, },
			{{-1, REDUCE, 27}, },
			{{-1, REDUCE, 24}, },
			{{-1, REDUCE, 25}, },
			{{-1, ERROR, 13}, {9, SHIFT, 23}, },
			{{-1, REDUCE, 0}, },
			{{-1, REDUCE, 26}, },
			{{-1, ERROR, 16}, {7, SHIFT, 19}, },
			{{-1, ERROR, 17}, {11, SHIFT, 25}, },
			{{-1, REDUCE, 19}, },
			{{-1, ERROR, 19}, {0, SHIFT, 17}, },
			{{-1, REDUCE, 18}, },
			{{-1, ERROR, 21}, {8, SHIFT, 29}, {11, SHIFT, 30}, },
			{{-1, ERROR, 22}, {8, SHIFT, 33}, {11, SHIFT, 34}, },
			{{-1, REDUCE, 30}, {1, SHIFT, 1}, {2, SHIFT, 2}, {3, SHIFT, 3}, {4, SHIFT, 4}, {5, SHIFT, 5}, {6, SHIFT, 6}, },
			{{-1, ERROR, 24}, {10, SHIFT, 40}, },
			{{-1, REDUCE, 17}, },
			{{-1, ERROR, 26}, {8, SHIFT, 41}, },
			{{-1, REDUCE, 2}, {0, SHIFT, 17}, },
			{{-1, REDUCE, 6}, },
			{{-1, REDUCE, 9}, },
			{{-1, REDUCE, 7}, },
			{{-1, REDUCE, 12}, },
			{{-1, ERROR, 32}, {8, SHIFT, 44}, {11, SHIFT, 30}, },
			{{-1, REDUCE, 13}, },
			{{-1, REDUCE, 8}, },
			{{-1, REDUCE, 16}, },
			{{-1, ERROR, 36}, {8, SHIFT, 46}, {11, SHIFT, 34}, },
			{{-1, ERROR, 37}, {9, SHIFT, 48}, },
			{{-1, REDUCE, 33}, },
			{{-1, REDUCE, 31}, {1, SHIFT, 1}, {2, SHIFT, 2}, {3, SHIFT, 3}, {4, SHIFT, 4}, {5, SHIFT, 5}, {6, SHIFT, 6}, },
			{{-1, ERROR, 40}, {0, SHIFT, 17}, {7, SHIFT, 19}, },
			{{-1, REDUCE, 1}, },
			{{-1, REDUCE, 5}, },
			{{-1, REDUCE, 3}, {0, SHIFT, 17}, },
			{{-1, REDUCE, 10}, },
			{{-1, REDUCE, 11}, },
			{{-1, REDUCE, 14}, },
			{{-1, REDUCE, 15}, },
			{{-1, REDUCE, 34}, },
			{{-1, REDUCE, 32}, },
			{{-1, REDUCE, 23}, },
			{{-1, REDUCE, 22}, },
			{{-1, REDUCE, 20}, },
			{{-1, REDUCE, 21}, },
			{{-1, REDUCE, 4}, },
        };*/
    private static int[][][] gotoTable;
/*      {
			{{-1, 7}, },
			{{-1, 20}, {16, 24}, {40, 50}, },
			{{-1, 26}, },
			{{-1, 27}, },
			{{-1, 31}, {32, 45}, },
			{{-1, 35}, {36, 47}, },
			{{-1, 8}, },
			{{-1, 9}, },
			{{-1, 18}, {19, 28}, {27, 42}, {40, 51}, {43, 54}, },
			{{-1, 10}, },
			{{-1, 11}, },
			{{-1, 12}, {1, 15}, },
			{{-1, 52}, },
			{{-1, 53}, },
			{{-1, 37}, {0, 13}, },
			{{-1, 14}, },
			{{-1, 38}, {39, 49}, },
			{{-1, 43}, },
			{{-1, 32}, },
			{{-1, 36}, },
			{{-1, 39}, },
        };*/
    private static String[] errorMessages;
/*      {
			"TFrozen TTech TRes TTarg TNonft TNonpt expected.",
			"TTech expected.",
			"TIdentifier expected.",
			"TFloatingConstant expected.",
			"TBra expected.",
			"EOF expected.",
			"TSemicolon expected.",
			"TKet TIdentifier expected.",
			"TFrozen TTech TRes TTarg TNonft TNonpt EOF expected.",
			"TArrow expected.",
			"TFloatingConstant TKet TSemicolon expected.",
			"TKet expected.",
			"TFloatingConstant TKet expected.",
			"TFloatingConstant TBra expected.",
			"TSemicolon TArrow expected.",
        };*/
    private static int[] errors;
/*      {
			0, 1, 2, 3, 4, 4, 4, 5, 6, 6, 6, 6, 6, 6, 5, 6, 4, 2, 6, 3, 6, 7, 7, 8, 9, 10, 11, 12, 12, 6, 7, 7, 7, 6, 7, 7, 7, 6, 8, 8, 13, 14, 12, 12, 6, 7, 6, 7, 8, 8, 6, 6, 6, 6, 12, 
        };*/
}
